// Parity tests for biofabric-rs.
//
// These integration tests compare the output of biofabric-rs against golden
// files generated by the original Java BioFabric tool. The goal is exact
// byte-level parity for node order (.noa), link order (.eda), and session
// XML (.bif) files.
//
// == Setup ==
//
// Before running these tests, golden files must be generated:
//
//   ./tests/parity/generate_goldens.sh
//
// This builds BioFabric in a Docker container and produces reference outputs
// under tests/parity/goldens/.
//
// == Running ==
//
//   cargo test --test parity_tests                      # skips if goldens missing
//   cargo test --test parity_tests -- --include-ignored # run all
//   cargo test --test parity_tests -- --nocapture       # with output

use std::path::PathBuf;

// ---------------------------------------------------------------------------
// Test infrastructure
// ---------------------------------------------------------------------------

/// Root of the parity test data.
fn parity_root() -> PathBuf {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    manifest_dir.join("../../tests/parity")
}

/// Path to a test network input file.
/// Automatically routes to the sif/ or gw/ subdirectory based on extension.
fn network_path(filename: &str) -> PathBuf {
    let subdir = match filename.rsplit('.').next() {
        Some("sif") => "sif",
        Some("gw") => "gw",
        _ => "sif",
    };
    parity_root().join("networks").join(subdir).join(filename)
}

/// Path to a golden output directory.
fn golden_dir(dirname: &str) -> PathBuf {
    parity_root().join("goldens").join(dirname)
}

/// Check if golden files exist for a given test. Returns false (and prints a
/// message) if they haven't been generated yet.
fn goldens_available(dirname: &str) -> bool {
    let dir = golden_dir(dirname);
    if !dir.exists() {
        eprintln!(
            "SKIP: golden files not found at {}. Run ./tests/parity/generate_goldens.sh first.",
            dir.display()
        );
        return false;
    }
    dir.join("output.noa").exists()
        || dir.join("output.eda").exists()
        || dir.join("output.bif").exists()
}

/// Read a golden file and return its contents as a string.
fn read_golden(dirname: &str, filename: &str) -> String {
    let path = golden_dir(dirname).join(filename);
    std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("Failed to read golden file {}: {}", path.display(), e))
}

/// Compare two strings with a detailed diff on failure.
fn assert_parity(label: &str, expected: &str, actual: &str) {
    if expected != actual {
        let exp_lines: Vec<&str> = expected.lines().collect();
        let act_lines: Vec<&str> = actual.lines().collect();

        let mut first_diff_line = None;
        for (i, (e, a)) in exp_lines.iter().zip(act_lines.iter()).enumerate() {
            if e != a {
                first_diff_line = Some(i + 1);
                break;
            }
        }
        if first_diff_line.is_none() && exp_lines.len() != act_lines.len() {
            first_diff_line = Some(exp_lines.len().min(act_lines.len()) + 1);
        }

        let msg = match first_diff_line {
            Some(line) => {
                let exp_content = exp_lines.get(line - 1).unwrap_or(&"<EOF>");
                let act_content = act_lines.get(line - 1).unwrap_or(&"<EOF>");
                format!(
                    "PARITY FAILURE in {label}:\n\
                     First difference at line {line}:\n\
                     Expected: {exp_content:?}\n\
                     Actual:   {act_content:?}\n\
                     Expected total lines: {}\n\
                     Actual total lines:   {}",
                    exp_lines.len(),
                    act_lines.len()
                )
            }
            None => format!(
                "PARITY FAILURE in {label}: outputs differ but couldn't locate difference"
            ),
        };
        panic!("{}", msg);
    }
}

// ---------------------------------------------------------------------------
// Parity test runner
// ---------------------------------------------------------------------------

/// Run a full parity test for a given input and golden directory.
///
/// Steps:
///   1. Load the network from the input file
///   2. Apply the layout algorithm
///   3. Export .noa, .eda, .bif
///   4. Compare each output against the golden file
#[allow(dead_code)]
fn run_parity_test(input_file: &str, golden_dirname: &str, compare: &[&str]) {
    if !goldens_available(golden_dirname) {
        return;
    }

    let input = network_path(input_file);
    assert!(input.exists(), "Input file not found: {}", input.display());

    // ---- STEP 1: Load the network ----
    // TODO: Replace with actual biofabric-rs parsing
    // let network = biofabric_core::io::sif::parse_sif(&input).unwrap();

    // ---- STEP 2: Apply default layout ----
    // TODO: Replace with actual layout algorithm
    // let layout_result = biofabric_core::layout::default::DefaultLayout::new()
    //     .layout(&network, &config);

    // ---- STEP 3: Export and compare ----

    if compare.contains(&"noa") {
        let golden_noa = read_golden(golden_dirname, "output.noa");
        // TODO: let actual_noa = write_noa_string(&layout_result);
        // assert_parity("NOA (node order)", &golden_noa, &actual_noa);
        let _ = golden_noa;
        eprintln!("  NOA comparison: STUB (not yet implemented)");
    }

    if compare.contains(&"eda") {
        let golden_eda = read_golden(golden_dirname, "output.eda");
        // TODO: let actual_eda = write_eda_string(&layout_result);
        // assert_parity("EDA (link order)", &golden_eda, &actual_eda);
        let _ = golden_eda;
        eprintln!("  EDA comparison: STUB (not yet implemented)");
    }

    if compare.contains(&"bif") {
        let golden_bif = read_golden(golden_dirname, "output.bif");
        // TODO: let actual_bif = write_session_string(&layout_result);
        // assert_parity("BIF (session XML)", &golden_bif, &actual_bif);
        let _ = golden_bif;
        eprintln!("  BIF comparison: STUB (not yet implemented)");
    }
}

// ---------------------------------------------------------------------------
// Test macro
// ---------------------------------------------------------------------------

macro_rules! parity_test {
    (
        name: $name:ident,
        input: $input:expr,
        golden: $golden:expr,
        compare: [$($fmt:expr),+ $(,)?]
    ) => {
        #[test]
        #[ignore = "parity test: enable after implementing the pipeline"]
        fn $name() {
            run_parity_test($input, $golden, &[$($fmt),+]);
        }
    };
}

// ===========================================================================
// SIF — Edge-case networks
// ===========================================================================

parity_test! { name: sif_triangle,                input: "triangle.sif",               golden: "triangle_default",               compare: ["noa", "eda", "bif"] }
parity_test! { name: sif_self_loop,               input: "self_loop.sif",              golden: "self_loop_default",              compare: ["noa", "eda", "bif"] }
parity_test! { name: sif_isolated_nodes,          input: "isolated_nodes.sif",         golden: "isolated_nodes_default",         compare: ["noa", "eda", "bif"] }
parity_test! { name: sif_disconnected_components, input: "disconnected_components.sif", golden: "disconnected_components_default", compare: ["noa", "eda", "bif"] }
parity_test! { name: sif_multi_relation,          input: "multi_relation.sif",         golden: "multi_relation_default",         compare: ["noa", "eda", "bif"] }

// ===========================================================================
// SIF — Real-world / stress networks
// ===========================================================================

parity_test! { name: sif_star500,     input: "star-500.sif",    golden: "star-500_default",    compare: ["noa", "eda", "bif"] }
parity_test! { name: sif_ba2k,        input: "ba2K.sif",        golden: "ba2K_default",        compare: ["noa", "eda", "bif"] }
parity_test! { name: sif_bind_human,  input: "BINDhuman.sif",   golden: "BINDhuman_default",   compare: ["noa", "eda", "bif"] }

// ===========================================================================
// GW — Hand-crafted
// ===========================================================================

parity_test! { name: gw_triangle,       input: "triangle.gw",          golden: "triangle_gw_default",          compare: ["noa", "eda", "bif"] }
parity_test! { name: gw_directed_tri,   input: "directed_triangle.gw", golden: "directed_triangle_gw_default", compare: ["noa", "eda", "bif"] }

// ===========================================================================
// GW — Real-world (SANA)
// ===========================================================================

parity_test! { name: gw_rnorvegicus, input: "RNorvegicus.gw", golden: "RNorvegicus_gw_default", compare: ["noa", "eda", "bif"] }
parity_test! { name: gw_celegans,    input: "CElegans.gw",    golden: "CElegans_gw_default",    compare: ["noa", "eda", "bif"] }
parity_test! { name: gw_yeast,       input: "yeast.gw",       golden: "yeast_gw_default",       compare: ["noa", "eda", "bif"] }
